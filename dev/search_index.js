var documenterSearchIndex = {"docs":
[{"location":"protocol/#Protocol-messages","page":"Protocol messages","title":"Protocol messages","text":"","category":"section"},{"location":"protocol/","page":"Protocol messages","title":"Protocol messages","text":"NATS.Info\nNATS.Connect\nNATS.Pub\nNATS.Sub\nNATS.Unsub\nNATS.Msg\nNATS.Ping\nNATS.Pong\nNATS.Err\nNATS.Ok","category":"page"},{"location":"protocol/#NATS.Info","page":"Protocol messages","title":"NATS.Info","text":"A client will need to start as a plain TCP connection, then when the server accepts a connection from the client, it will send information about itself, the configuration and security requirements necessary for the client to successfully authenticate with the server and exchange messages. When using the updated client protocol (see CONNECT below), INFO messages can be sent anytime by the server. This means clients with that protocol level need to be able to asynchronously handle INFO messages.\n\nserver_id::String: The unique identifier of the NATS server.\nserver_name::String: The name of the NATS server.\nversion::String: The version of NATS.\ngo::String: The version of golang the NATS server was built with.\nhost::String: The IP address used to start the NATS server, by default this will be 0.0.0.0 and can be configured with -client_advertise host:port.\nport::Int64: The port number the NATS server is configured to listen on.\nheaders::Bool: Whether the server supports headers.\nmax_payload::Int64: Maximum payload size, in bytes, that the server will accept from the client.\nproto::Int64: An integer indicating the protocol version of the server. The server version 1.2.0 sets this to 1 to indicate that it supports the \"Echo\" feature.\nclient_id::Union{Nothing, UInt64}: The internal client identifier in the server. This can be used to filter client connections in monitoring, correlate with error logs, etc...\nauth_required::Union{Nothing, Bool}: If this is true, then the client should try to authenticate upon connect.\ntls_required::Union{Nothing, Bool}: If this is true, then the client must perform the TLS/1.2 handshake. Note, this used to be ssl_required and has been updated along with the protocol from SSL to TLS.\ntls_verify::Union{Nothing, Bool}: If this is true, the client must provide a valid certificate during the TLS handshake.\ntls_available::Union{Nothing, Bool}: If this is true, the client can provide a valid certificate during the TLS handshake.\nconnect_urls::Union{Nothing, Vector{String}}: List of server urls that a client can connect to.\nws_connect_urls::Union{Nothing, Vector{String}}: List of server urls that a websocket client can connect to.\nldm::Union{Nothing, Bool}: If the server supports Lame Duck Mode notifications, and the current server has transitioned to lame duck, ldm will be set to true.\ngit_commit::Union{Nothing, String}: The git hash at which the NATS server was built.\njetstream::Union{Nothing, Bool}: Whether the server supports JetStream.\nip::Union{Nothing, String}: The IP of the server.\nclient_ip::Union{Nothing, String}: The IP of the client.\nnonce::Union{Nothing, String}: The nonce for use in CONNECT.\ncluster::Union{Nothing, String}: The name of the cluster.\ndomain::Union{Nothing, String}: The configured NATS domain of the server.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#NATS.Connect","page":"Protocol messages","title":"NATS.Connect","text":"The CONNECT message is the client version of the INFO message. Once the client has established a TCP/IP socket connection with the NATS server, and an INFO message has been received from the server, the client may send a CONNECT message to the NATS server to provide more information about the current connection as well as security information.\n\nverbose::Bool: Turns on +OK protocol acknowledgements.\npedantic::Bool: Turns on additional strict format checking, e.g. for properly formed subjects.\ntls_required::Bool: Indicates whether the client requires SSL connection.\nauth_token::Union{Nothing, String}: Client authorization token.\nuser::Union{Nothing, String}: Connection username.\npass::Union{Nothing, String}: Connection password.\nname::Union{Nothing, String}: Client name.\nlang::String: The implementation language of the client.\nversion::String: The version of the client.\nprotocol::Union{Nothing, Int64}: Sending 0 (or absent) indicates client supports original protocol. Sending 1 indicates that the client supports dynamic reconfiguration of cluster topology changes by asynchronously receiving INFO messages with known servers it can reconnect to.\necho::Union{Nothing, Bool}: If set to false, the server (version 1.2.0+) will not send originating messages from this connection to its own subscriptions. Clients should set this to false only for server supporting this feature, which is when proto in the INFO protocol is set to at least 1.\nsig::Union{Nothing, String}: In case the server has responded with a nonce on INFO, then a NATS client must use this field to reply with the signed nonce.\njwt::Union{Nothing, String}: The JWT that identifies a user permissions and account.\nno_responders::Union{Nothing, Bool}: Enable quick replies for cases where a request is sent to a topic with no responders.\nheaders::Union{Nothing, Bool}: Whether the client supports headers.\nnkey::Union{Nothing, String}: The public NKey to authenticate the client. This will be used to verify the signature (sig) against the nonce provided in the INFO message.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#NATS.Pub","page":"Protocol messages","title":"NATS.Pub","text":"The PUB message publishes the message payload to the given subject name, optionally supplying a reply subject. If a reply subject is supplied, it will be delivered to eligible subscribers along with the supplied payload. Note that the payload itself is optional. To omit the payload, set the payload size to 0, but the second CRLF is still required.\n\nThe HPUB message is the same as PUB but extends the message payload to include NATS headers. Note that the payload itself is optional. To omit the payload, set the total message size equal to the size of the headers. Note that the trailing CR+LF is still required.\n\nsubject::String: The destination subject to publish to.\nreply_to::Union{Nothing, String}: The reply subject that subscribers can use to send a response back to the publisher/requestor.\nheaders_length::Int64: Length of headers data inside payload\npayload::Vector{UInt8}: Optional headers (NATS/1.0␍␊ followed by one or more name: value pairs, each separated by ␍␊) followed by payload data.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#NATS.Sub","page":"Protocol messages","title":"NATS.Sub","text":"SUB initiates a subscription to a subject, optionally joining a distributed queue group.\n\nsubject::String: The subject name to subscribe to.\nqueue_group::Union{Nothing, String}: If specified, the subscriber will join this queue group.\nsid::String: A unique alphanumeric subscription ID, generated by the client.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#NATS.Unsub","page":"Protocol messages","title":"NATS.Unsub","text":"UNSUB unsubscribes the connection from the specified subject, or auto-unsubscribes after the specified number of messages has been received.\n\nsid::String: The unique alphanumeric subscription ID of the subject to unsubscribe from.\nmax_msgs::Union{Nothing, Int64}: A number of messages to wait for before automatically unsubscribing.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#NATS.Msg","page":"Protocol messages","title":"NATS.Msg","text":"The MSG protocol message is used to deliver an application message to the client.\n\nThe HMSG message is the same as MSG, but extends the message payload with headers. See also ADR-4 NATS Message Headers.\n\nsubject::String: Subject name this message was received on.\nsid::String: The unique alphanumeric subscription ID of the subject.\nreply_to::Union{Nothing, String}: The subject on which the publisher is listening for responses.\nheaders_length::Int64: Length of headers data inside payload\npayload::AbstractVector{UInt8}: Optional headers (NATS/1.0␍␊ followed by one or more name: value pairs, each separated by ␍␊) followed by payload data.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#NATS.Ping","page":"Protocol messages","title":"NATS.Ping","text":"PING and PONG implement a simple keep-alive mechanism between client and server.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#NATS.Pong","page":"Protocol messages","title":"NATS.Pong","text":"PING and PONG implement a simple keep-alive mechanism between client and server.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#NATS.Err","page":"Protocol messages","title":"NATS.Err","text":"The -ERR message is used by the server indicate a protocol, authorization, or other runtime connection error to the client. Most of these errors result in the server closing the connection.\n\nmessage::String: Error message.\n\n\n\n\n\n","category":"type"},{"location":"protocol/#NATS.Ok","page":"Protocol messages","title":"NATS.Ok","text":"When the verbose connection option is set to true (the default value), the server acknowledges each well-formed protocol message from the client with a +OK message.\n\n\n\n\n\n","category":"type"},{"location":"jetstream/jetdict/#JetDict","page":"JetDict","title":"JetDict","text":"","category":"section"},{"location":"jetstream/jetdict/#Basic-usage","page":"JetDict","title":"Basic usage","text":"","category":"section"},{"location":"jetstream/jetdict/","page":"JetDict","title":"JetDict","text":"using NATS\nusing NATS.JetStream\nnc = NATS.connect()\nkv = JetDict{String}(nc, \"example_kv\")\nkv[\"key1\"] = \"Value 1\"\nkv[\"key2\"] = \"Value 2\"\nkv\ndelete!(kv, \"key1\")\nkeyvalue_stream_delete(nc, \"example_kv\")","category":"page"},{"location":"jetstream/jetdict/#Key-encoding","page":"JetDict","title":"Key encoding","text":"","category":"section"},{"location":"jetstream/jetdict/","page":"JetDict","title":"JetDict","text":"Keys of keyvalue stream have limitations. They cannot start and and with '.' and can contain limited set of characters.","category":"page"},{"location":"jetstream/jetdict/","page":"JetDict","title":"JetDict","text":"Alowed characters:","category":"page"},{"location":"jetstream/jetdict/","page":"JetDict","title":"JetDict","text":"letters\ndigits\n'-', '/', '_', '=', '.'","category":"page"},{"location":"jetstream/jetdict/","page":"JetDict","title":"JetDict","text":"To allow arbitrary string as a key :base64url encoding parameter may be specified.","category":"page"},{"location":"jetstream/jetdict/","page":"JetDict","title":"JetDict","text":"using NATS\nusing NATS.JetStream\nnc = NATS.connect()\nkv = JetDict{String}(nc, \"example_kv_enc\", :base64url)\nkv[\"encoded_key1\"] = \"Value 1\"\nkv[\"!@#%^&\"] = \"Value 2\"\nkv[\"!@#%^&\"]\nkeyvalue_stream_delete(nc, \"example_kv_enc\")","category":"page"},{"location":"jetstream/jetdict/#Custom-values","page":"JetDict","title":"Custom values","text":"","category":"section"},{"location":"jetstream/jetdict/","page":"JetDict","title":"JetDict","text":"using NATS\nusing NATS.JetStream\nimport Base: show, convert\nstruct Person\n    name::String\n    age::Int64\nend\nfunction convert(::Type{Person}, msg::NATS.Msg)\n    name, age = split(payload(msg), \",\")\n    Person(name, parse(Int64, age))\nend\nfunction show(io::IO, ::NATS.MIME_PAYLOAD, person::Person)\n    print(io, person.name)\n    print(io, \",\")\n    print(io, person.age)\nend\nnc = NATS.connect()\nkv = JetDict{Person}(nc, \"people\")\nkv[\"jakub\"] = Person(\"jakub\", 22)\nkv[\"martha\"] = Person(\"martha\", 22)\nkv[\"martha\"]\nkv\nkeyvalue_stream_delete(nc, \"people\")","category":"page"},{"location":"jetstream/jetdict/#Watching-changes","page":"JetDict","title":"Watching changes","text":"","category":"section"},{"location":"jetstream/jetdict/","page":"JetDict","title":"JetDict","text":"using NATS\nusing NATS.JetStream\nnc = NATS.connect()\nkv = JetDict{String}(nc, \"example_kv_watch\")\nsub = watch(kv) do change\n    @show change\nend\n@async begin\n    kv[\"a\"] = \"1\"\n    kv[\"b\"] = \"2\"\n    delete!(kv, \"a\")\n    kv[\"b\"] = \"3\"\n    kv[\"a\"] = \"4\"\nend\nsleep(1) # Wait for changes\nstream_unsubscribe(nc, sub)\nkeyvalue_stream_delete(nc, \"example_kv_watch\")","category":"page"},{"location":"custom-data/#Transport-data-structures","page":"Transport data structures","title":"Transport data structures","text":"","category":"section"},{"location":"custom-data/#Using-custom-types-as-handler-input","page":"Transport data structures","title":"Using custom types as handler input","text":"","category":"section"},{"location":"custom-data/","page":"Transport data structures","title":"Transport data structures","text":"It is possible to use and return custom types inside subscription handlers if convert method from NATS.Msg is provided. See src/protocol/convert.jl for example implementation for String.","category":"page"},{"location":"custom-data/","page":"Transport data structures","title":"Transport data structures","text":"using NATS\nstruct Person\n    name::String\n    age::Int64\nend\nimport Base: convert\nfunction convert(::Type{Person}, msg::NATS.Msg)\n    name, age = split(payload(msg), \",\")\n    Person(name, parse(Int64, age))\nend\nconnection = NATS.connect() # Important to create a connection after `convert` is defined\nsub = subscribe(connection, \"EMPLOYEES\") do person::Person\n    @show person\nend\npublish(connection, \"EMPLOYEES\", \"John,44\")\nsleep(0.2) # Wait for message delivered to sub\ndrain(connection, sub)","category":"page"},{"location":"custom-data/#Returning-custom-types-from-handler","page":"Transport data structures","title":"Returning custom types from handler","text":"","category":"section"},{"location":"custom-data/","page":"Transport data structures","title":"Transport data structures","text":"It is also possible to return any type from a handler in reply and put any type as publish argument if conversion to UTF-8 string is provided.   Note that both Julia and NATS protocol use UTF-8 encoding, so no additional conversions are needed.","category":"page"},{"location":"custom-data/","page":"Transport data structures","title":"Transport data structures","text":"NATS module defines custom MIME types for payload and headers serialization:","category":"page"},{"location":"custom-data/","page":"Transport data structures","title":"Transport data structures","text":"const MIME_PAYLOAD  = MIME\"application/nats-payload\"\nconst MIME_HEADERS  = MIME\"application/nats-headers\"","category":"page"},{"location":"custom-data/","page":"Transport data structures","title":"Transport data structures","text":"Conversion method should look like this.","category":"page"},{"location":"custom-data/","page":"Transport data structures","title":"Transport data structures","text":"using NATS\nstruct Person\n    name::String\n    age::Int64\nend\nimport Base: convert, show\nfunction convert(::Type{Person}, msg::NATS.Msg)\n    name, age = split(payload(msg), \",\")\n    Person(name, parse(Int64, age))\nend\nfunction show(io::IO, ::NATS.MIME_PAYLOAD, person::Person)\n    print(io, person.name)\n    print(io, \",\")\n    print(io, person.age)\nend\nconnection = NATS.connect()\nsub = reply(connection, \"EMPLOYEES.SUPERVISOR\") do person::Person\n    if person.name == \"Alice\"\n        Person(\"Bob\", 44)\n    else\n        Person(\"Unknown\", 0)\n    end\nend\nrequest(Person, connection, \"EMPLOYEES.SUPERVISOR\", Person(\"Alice\", 22))\ndrain(connection, sub)","category":"page"},{"location":"custom-data/#Error-handling","page":"Transport data structures","title":"Error handling","text":"","category":"section"},{"location":"custom-data/","page":"Transport data structures","title":"Transport data structures","text":"Errors can be handled with custom headers.","category":"page"},{"location":"custom-data/","page":"Transport data structures","title":"Transport data structures","text":"using NATS\nimport Base: convert, show\nstruct Person\n    name::String\n    age::Int64\n    departament::String\nend\nfunction convert(::Type{Person}, msg::NATS.Msg)\n    name, age, departament = split(payload(msg), \",\")\n    Person(name, parse(Int64, age), departament)\nend\nfunction show(io::IO, ::NATS.MIME_PAYLOAD, person::Person)\n    print(io, person.name)\n    print(io, \",\")\n    print(io, person.age)\n    print(io, \",\")\n    print(io, person.departament)\nend\nnc = NATS.connect()\nsub = reply(nc, \"EMPLOYEES.SUPERVISOR\") do person::Person\n    \n    if person.name == \"Alice\"\n        Person(\"Bob\", 44, \"IT\"), [\"status\" => \"ok\"]\n    else\n        Person(\"Unknown\", 0, \"\"), [\"status\" => \"error\", \"message\" => \"Supervisor not defined for $(person.name)\" ]\n    end\nend\nrequest(Person, nc, \"EMPLOYEES.SUPERVISOR\", Person(\"Alice\", 33, \"IT\"))\nerror_response = request(nc, \"EMPLOYEES.SUPERVISOR\", Person(\"Anna\", 33, \"ACCOUNTING\"));\nheaders(error_response)\ndrain(nc, sub)","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Procedures to compare NATS.jl performance with go implementation.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Prerequisites:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"start nats-server","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"docker run -p 4222:4222 nats:latest","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"enusre nats CLI tool is installed","category":"page"},{"location":"benchmarks/#Request-Reply-latency","page":"Benchmarks","title":"Request-Reply latency","text":"","category":"section"},{"location":"benchmarks/#Native-go-latency","page":"Benchmarks","title":"Native go latency","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Start reply service","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"> nats reply foo \"This is a reply\" 2> /dev/null > /dev/null","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Run benchmark with 1 publisher","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"> nats bench foo --pub 1 --request --msgs 1000\n13:25:53 Benchmark in request-reply mode\n13:25:53 Starting request-reply benchmark [subject=foo, multisubject=false, multisubjectmax=0, request=true, reply=false, msgs=1,000, msgsize=128 B, pubs=1, subs=0, pubsleep=0s, subsleep=0s]\n13:25:53 Starting publisher, publishing 1,000 messages\nFinished      0s [================] 100%\n\nPub stats: 1,676 msgs/sec ~ 209.57 KB/sec","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Run benchmark with 10 publishers","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"> nats bench foo --pub 10 --request --msgs 10000\n13:30:52 Benchmark in request-reply mode\n13:30:52 Starting request-reply benchmark [subject=foo, multisubject=false, multisubjectmax=0, request=true, reply=false, msgs=10,000, msgsize=128 B, pubs=10, subs=0, pubsleep=0s, subsleep=0s]\n13:30:52 Starting publisher, publishing 1,000 messages\n13:30:52 Starting publisher, publishing 1,000 messages\n13:30:52 Starting publisher, publishing 1,000 messages\n13:30:52 Starting publisher, publishing 1,000 messages\n13:30:52 Starting publisher, publishing 1,000 messages\n13:30:52 Starting publisher, publishing 1,000 messages\n13:30:52 Starting publisher, publishing 1,000 messages\n13:30:52 Starting publisher, publishing 1,000 messages\n13:30:52 Starting publisher, publishing 1,000 messages\n13:30:52 Starting publisher, publishing 1,000 messages\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\n\nPub stats: 11,522 msgs/sec ~ 1.41 MB/sec\n [1] 1,158 msgs/sec ~ 144.85 KB/sec (1000 msgs)\n [2] 1,158 msgs/sec ~ 144.84 KB/sec (1000 msgs)\n [3] 1,158 msgs/sec ~ 144.79 KB/sec (1000 msgs)\n [4] 1,157 msgs/sec ~ 144.73 KB/sec (1000 msgs)\n [5] 1,157 msgs/sec ~ 144.68 KB/sec (1000 msgs)\n [6] 1,156 msgs/sec ~ 144.62 KB/sec (1000 msgs)\n [7] 1,154 msgs/sec ~ 144.36 KB/sec (1000 msgs)\n [8] 1,153 msgs/sec ~ 144.22 KB/sec (1000 msgs)\n [9] 1,153 msgs/sec ~ 144.13 KB/sec (1000 msgs)\n [10] 1,152 msgs/sec ~ 144.03 KB/sec (1000 msgs)\n min 1,152 | avg 1,155 | max 1,158 | stddev 2 msgs","category":"page"},{"location":"benchmarks/#NATS.jl-latency","page":"Benchmarks","title":"NATS.jl latency","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Start reply service","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia> using NATS\njulia> nc = NATS.connect();\njulia> reply(nc, \"foo\") do\n           \"This is a reply.\"\n       end\nNATS.Sub(\"foo\", nothing, \"PDrH5FOxIgBpcnLO4xHD\")","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Run benchmark with 1 publisher:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"> nats bench foo --pub 1 --request --msgs 1000\n13:28:56 Benchmark in request-reply mode\n13:28:56 Starting request-reply benchmark [subject=foo, multisubject=false, multisubjectmax=0, request=true, reply=false, msgs=1,000, msgsize=128 B, pubs=1, subs=0, pubsleep=0s, subsleep=0s]\n13:28:56 Starting publisher, publishing 1,000 messages\nFinished      0s [================] 100%\n\nPub stats: 1,565 msgs/sec ~ 195.64 KB/sec","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Run benchmark with 10 publishers:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"nats bench foo --pub 10 --request --msgs 10000\n13:29:51 Benchmark in request-reply mode\n13:29:51 Starting request-reply benchmark [subject=foo, multisubject=false, multisubjectmax=0, request=true, reply=false, msgs=10,000, msgsize=128 B, pubs=10, subs=0, pubsleep=0s, subsleep=0s]\n13:29:51 Starting publisher, publishing 1,000 messages\n13:29:51 Starting publisher, publishing 1,000 messages\n13:29:51 Starting publisher, publishing 1,000 messages\n13:29:51 Starting publisher, publishing 1,000 messages\n13:29:51 Starting publisher, publishing 1,000 messages\n13:29:51 Starting publisher, publishing 1,000 messages\n13:29:51 Starting publisher, publishing 1,000 messages\n13:29:51 Starting publisher, publishing 1,000 messages\n13:29:51 Starting publisher, publishing 1,000 messages\n13:29:51 Starting publisher, publishing 1,000 messages\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\nFinished      0s [================] 100%\n\nPub stats: 11,880 msgs/sec ~ 1.45 MB/sec\n [1] 1,204 msgs/sec ~ 150.62 KB/sec (1000 msgs)\n [2] 1,198 msgs/sec ~ 149.85 KB/sec (1000 msgs)\n [3] 1,197 msgs/sec ~ 149.70 KB/sec (1000 msgs)\n [4] 1,194 msgs/sec ~ 149.31 KB/sec (1000 msgs)\n [5] 1,193 msgs/sec ~ 149.20 KB/sec (1000 msgs)\n [6] 1,192 msgs/sec ~ 149.09 KB/sec (1000 msgs)\n [7] 1,192 msgs/sec ~ 149.06 KB/sec (1000 msgs)\n [8] 1,191 msgs/sec ~ 148.91 KB/sec (1000 msgs)\n [9] 1,191 msgs/sec ~ 148.88 KB/sec (1000 msgs)\n [10] 1,188 msgs/sec ~ 148.50 KB/sec (1000 msgs)\n min 1,188 | avg 1,194 | max 1,204 | stddev 4 msgs","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Results show 1,155 msgs/s for native go library and 1,194 msgs/s NATS.jl, we are good here.","category":"page"},{"location":"benchmarks/#Publish-Subscribe-benchmarks","page":"Benchmarks","title":"Publish-Subscribe benchmarks","text":"","category":"section"},{"location":"benchmarks/#Run-nats-CLI-benchmarks","page":"Benchmarks","title":"Run nats CLI benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"> nats bench foo --pub 1 --sub 1 --size 16\n13:43:05 Starting Core NATS pub/sub benchmark [subject=foo, multisubject=false, multisubjectmax=0, msgs=100,000, msgsize=16 B, pubs=1, subs=1, pubsleep=0s, subsleep=0s]\n13:43:05 Starting subscriber, expecting 100,000 messages\n13:43:05 Starting publisher, publishing 100,000 messages\nFinished      0s [================] 100%\nFinished      0s [================] 100%\n\nNATS Pub/Sub stats: 2,251,521 msgs/sec ~ 34.36 MB/sec\n Pub stats: 1,215,686 msgs/sec ~ 18.55 MB/sec\n Sub stats: 1,154,802 msgs/sec ~ 17.62 MB/sec\n","category":"page"},{"location":"benchmarks/#Benchmark-NATS.jl-publish","page":"Benchmarks","title":"Benchmark NATS.jl publish","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia> using NATS\n\njulia> nc = NATS.connect();\nThreads.threadid() = \njulia> \njulia> Threads.threadid() = 1\nThreads.threadid() = 1\njulia> \n\njulia> while true\n           for i in 1:100000\n            publish(nc, \"foo\", \"This is a payload\")\n           end\n           sleep(0.001)\n       end","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"> > nats bench foo --sub 1 --size 16\n13:46:23 Starting Core NATS pub/sub benchmark [subject=foo, multisubject=false, multisubjectmax=0, msgs=100,000, msgsize=16 B, pubs=0, subs=1, pubsleep=0s, subsleep=0s]\n13:46:23 Starting subscriber, expecting 100,000 messages\nFinished      0s [================] 100%\n\nSub stats: 904,350 msgs/sec ~ 13.80 MB/sec","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"0.9M msgs vs 1.2M messages, I think all good here, received messages are buffered and async processed in separate task.","category":"page"},{"location":"benchmarks/#Benchmark-NATS.jl-subscribe","page":"Benchmarks","title":"Benchmark NATS.jl subscribe","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Supress warnings","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia> using Logging\n\njulia> Logging.LogLevel(Error)\nError","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using NATS\nnc = NATS.connect(send_buffer_limit = 1000000000)\nfunction subscribe_until_timeout(nc::NATS.Connection, timeout = 1.0)\n    tm = Timer(timeout)\n    counter = 0\n    start = nothing\n    sub = subscribe(nc, \"foo\") do\n        if isnothing(start)\n            start = time()\n        end\n        counter += 1\n    end\n    wait(tm)\n    unsubscribe(nc, sub)\n    if counter == 0\n        @info \"No messages\"\n    else\n        @info \"Processed $counter messages in $(time() - start) s. $(counter / (time() - start)) msgs/sec)\"\n    end\n    counter\nend\n\nbench_task = @async begin\n    sub_task = Threads.@spawn :default subscribe_until_timeout(nc, 10.0)\n    Threads.@spawn :default while !istaskdone(sub_task)\n        publish(nc, \"foo\", \"This is payload!\")\n    end\n    wait(sub_task)\n    sub_task.result\nend\n_, tm = @timed wait(bench_task);\nreceived_messages = bench_task.result\n@info \"$(received_messages / tm) msgs / sec\"\n\n","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Start publisher:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"> nats bench foo --pub 1 --size 16 --msgs 20000000\n13:50:56 Starting Core NATS pub/sub benchmark [subject=foo, multisubject=false, multisubjectmax=0, msgs=20,000,000, msgsize=16 B, pubs=1, subs=0, pubsleep=0s, subsleep=0s]\n13:50:56 Starting publisher, publishing 20,000,000 messages\nPublishing    3s [==========>-----]  68%","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia> subscribe_for_one_second()\n[ Info: Processed 1680882 messages in 0.9680750370025635 s.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"1,68M messages in NATS.jl vs 1.7M messages by go client.","category":"page"},{"location":"scoped_connection/#Scoped-connection","page":"Scoped connection","title":"Scoped connection","text":"","category":"section"},{"location":"scoped_connection/","page":"Scoped connection","title":"Scoped connection","text":"This feature allows to use implicit connection in a block of code. It utilizes ScopedValues package.","category":"page"},{"location":"scoped_connection/#Functions","page":"Scoped connection","title":"Functions","text":"","category":"section"},{"location":"scoped_connection/","page":"Scoped connection","title":"Scoped connection","text":"with_connection","category":"page"},{"location":"scoped_connection/#NATS.with_connection","page":"Scoped connection","title":"NATS.with_connection","text":"with_connection(f, nc)\n\n\nCreate scope with ambient context connection, in which connection argument might be skipped during invocation of functions.\n\nUsage:\n\n    nc = NATS.connect()\n    with_connection(nc) do\n        publish(\"some.subject\") # No `connection` argument.\n    end\n\n\n\n\n\n","category":"function"},{"location":"scoped_connection/#Examples","page":"Scoped connection","title":"Examples","text":"","category":"section"},{"location":"scoped_connection/","page":"Scoped connection","title":"Scoped connection","text":"using NATS\nconn1 = NATS.connect()\nconn2 = NATS.connect()\n\nwith_connection(conn1) do\n    sub = subscribe(\"foo\") do msg\n        @show payload(msg)\n    end\n    sleep(0.1) # Wait some time to let server process sub.\n    with_connection(conn2) do\n        publish(\"foo\", \"Some payload\")\n    end\n    sleep(0.1) # Wait some time to message be delivered.\n    unsubscribe(sub)\n    nothing\nend\n\nconn1.stats.msgs_received == 1\nconn1.stats.msgs_published == 0\n\nconn2.stats.msgs_received == 0\nconn2.stats.msgs_published == 1\n","category":"page"},{"location":"reqreply/#Request-Reply","page":"Request - Reply","title":"Request - Reply","text":"","category":"section"},{"location":"reqreply/","page":"Request - Reply","title":"Request - Reply","text":"Functions implementing Request-Reply pattern.","category":"page"},{"location":"reqreply/","page":"Request - Reply","title":"Request - Reply","text":"request\nreply","category":"page"},{"location":"reqreply/#NATS.request","page":"Request - Reply","title":"NATS.request","text":"request(connection, subject; ...)\nrequest(connection, subject, data; timer)\n\n\nSend NATS Request-Reply message.\n\nDefault timeout is 5.0 seconds which can be overriden by passing timer. It can be configured globally with NATS_REQUEST_TIMEOUT_SECONDS env variable.\n\nOptional keyword arguments are:\n\ntimer: error will be thrown if no replies received until timer expires\n\nExamples\n\njulia> NATS.request(connection, \"help.please\")\nNATS.Msg(\"l9dKWs86\", \"7Nsv5SZs\", nothing, \"\", \"OK, I CAN HELP!!!\")\n\njulia> request(connection, \"help.please\"; timer = Timer(0))\nERROR: No replies received.\n\n\n\n\n\nrequest(connection, nreplies, subject; ...)\nrequest(connection, nreplies, subject, data; timer)\n\n\nRequests for multiple replies. Vector of messages is returned after receiving nreplies replies or timer expired. Can return less messages than specified (also empty array if timeout occurs), errors are not filtered.\n\nOptional keyword arguments are:\n\ntimer: empty vector will be returned if no replies received until timer expires\n\nExamples\n\njulia> request(connection, 2, \"help.please\"; timer = Timer(0))\nNATS.Msg[]\n\n\n\n\n\nRequest a reply from a service listening for subject messages. Reply is converted to specified type. Apropriate convert method must be defined, otherwise error is thrown.\n\n\n\n\n\n","category":"function"},{"location":"reqreply/#NATS.reply","page":"Request - Reply","title":"NATS.reply","text":"reply(f, connection, subject; queue_group, spawn)\n\n\nReply for messages for a subject. Works like subscribe with automatic publish to the subject from reply_to field.\n\nOptional keyword arguments are:\n\nqueue_group: NATS server will distribute messages across queue group members\nspawn: if true task will be spawn for each f invocation, otherwise messages are processed sequentially, default is false\n\nExamples\n\njulia> sub = reply(\"FOO.REQUESTS\") do msg\n    \"This is a reply payload.\"\nend\nNATS.Sub(\"FOO.REQUESTS\", nothing, \"jdnMEcJN\")\n\njulia> sub = reply(\"FOO.REQUESTS\") do msg\n    \"This is a reply payload.\", [\"example_header\" => \"This is a header value\"]\nend\nNATS.Sub(\"FOO.REQUESTS\", nothing, \"jdnMEcJN\")\n\njulia> unsubscribe(sub)\n\n\n\n\n\n","category":"function"},{"location":"debugging/#Debugging","page":"Debugging","title":"Debugging","text":"","category":"section"},{"location":"debugging/#Monitoring-connection-state","page":"Debugging","title":"Monitoring connection state","text":"","category":"section"},{"location":"debugging/","page":"Debugging","title":"Debugging","text":"using NATS\nnc = NATS.connect()\n@async NATS.status_change(nc) do state\n    @info \"Connection to $(NATS.clustername(nc)) changed state to $state\"\nend\nNATS.reconnect(nc)\nNATS.drain(nc)\nsleep(7) # Wait a moment to get DRAINED status as well","category":"page"},{"location":"debugging/#Connection-and-subscription-statistics","page":"Debugging","title":"Connection and subscription statistics","text":"","category":"section"},{"location":"debugging/","page":"Debugging","title":"Debugging","text":"There are detailed statistics of published and received messages collected. They can be accessed for each subscription and connection. Connection statistics aggregates stats for all its subscriptions.","category":"page"},{"location":"debugging/","page":"Debugging","title":"Debugging","text":"using NATS\nnc = NATS.connect()\nsub1 = subscribe(nc, \"topic\") do msg\n    t = Threads.@spawn publish(nc, \"other_topic\", payload(msg))\n    wait(t)    \nend\nsub2 = subscribe(nc, \"other_topic\") do msg\n    @show payload(msg)\nend\nNATS.stats(nc)\npublish(nc, \"topic\", \"Hi!\")\nNATS.stats(nc)\nNATS.stats(nc, sub1)\nNATS.stats(nc, sub2)\nsleep(0.1) # Wait for message to be propagated\nNATS.stats(nc)\nNATS.stats(nc, sub1)\nNATS.stats(nc, sub2)\nNATS.drain(nc)","category":"page"},{"location":"design/#Design-notes","page":"Design notes","title":"Design notes","text":"","category":"section"},{"location":"design/#Parsing","page":"Design notes","title":"Parsing","text":"","category":"section"},{"location":"design/","page":"Design notes","title":"Design notes","text":"Benchmark after any changes to parsing, \"4k requests\" is a good test case.","category":"page"},{"location":"design/#Use-split","page":"Design notes","title":"Use split","text":"","category":"section"},{"location":"design/","page":"Design notes","title":"Design notes","text":"Avoid using regex, split is used to extract protocol data. Some performance might be squeezed by avoiding conversion from SubString to String but it will be observable only for huge payloads.","category":"page"},{"location":"design/#Validation","page":"Design notes","title":"Validation","text":"","category":"section"},{"location":"design/","page":"Design notes","title":"Design notes","text":"Avoids regex as well if possible.","category":"page"},{"location":"design/","page":"Design notes","title":"Design notes","text":"Name regex: ^[^.*>]+$","category":"page"},{"location":"design/","page":"Design notes","title":"Design notes","text":"julia> function validate_name(name::String)\n           isempty(name) && error(\"Name is empty.\")\n           for c in name\n               if c == '.' || c == '*' || c == '>'\n                   error(\"Name \\\"$name\\\" contains invalid character '$c'.\")\n               end\n           end\n           true\n       end\nvalidate_name (generic function with 1 method)\n\njulia> function validate_name_regex(name::String)\n           m = match(r\"^[^.*>]+$\", name)\n           isnothing(m) && error(\"Invalid name.\")\n           true\n       end\nvalidate_name_regex (generic function with 1 method)\n\njulia> using BenchmarkTools\n\njulia> name = \"valid_name\"\n\"valid_name\"\n\njulia> @btime validate_name(name)\n  9.593 ns (0 allocations: 0 bytes)\ntrue\n\njulia> @btime validate_name_regex(name)\n  114.174 ns (3 allocations: 176 bytes)\ntrue\n","category":"page"},{"location":"design/#Use-strings-not-raw-bytes","page":"Design notes","title":"Use strings not raw bytes","text":"","category":"section"},{"location":"design/","page":"Design notes","title":"Design notes","text":"Parser is not returning raw bytes but rather String. This fast thanks to how String constructor works.","category":"page"},{"location":"design/","page":"Design notes","title":"Design notes","text":"julia> bytes = UInt8['a', 'b', 'c'];\n\njulia> str = String(bytes)\n\"abc\"\n\njulia> bytes\nUInt8[]\n\njulia> @doc String\n  ...\n  When possible, the memory of v will be used without copying when the String object is created.\n  This is guaranteed to be the case for byte vectors returned by take! on a writable IOBuffer\n  and by calls to read(io, nb). This allows zero-copy conversion of I/O data to strings. In\n  other cases, Vector{UInt8} data may be copied, but v is truncated anyway to guarantee\n  consistent behavior.\n  ...","category":"page"},{"location":"connect/#Connection","page":"Connection","title":"Connection","text":"","category":"section"},{"location":"connect/#Connecting","page":"Connection","title":"Connecting","text":"","category":"section"},{"location":"connect/","page":"Connection","title":"Connection","text":"connect","category":"page"},{"location":"connect/#NATS.connect","page":"Connection","title":"NATS.connect","text":"connect(; ...)\nconnect(url; options...)\n\n\nConnect to NATS server. The function is blocking until connection is initialized. In case of error during initialization process connect will throw exception if retry_on_init_fail is set to false (what is default). Otherwise handle will be returned and reconnect will continue in background.\n\nOptions are:\n\nverbose: turns on protocol acknowledgements\npedantic: turns on additional strict format checking, e.g. for properly formed subjects\ntls_required: indicates whether the client requires SSL connection\ntls_ca_path: CA certuficate file path\ntls_cert_path: client public certificate file\ntls_key_path: client private certificate file\nauth_token: client authorization token\nuser: connection username\npass: connection password\nname: client name\necho: if set to false, the server will not send originating messages from this connection to its own subscriptions\njwt: the JWT that identifies a user permissions and account.\nno_responders: enable quick replies for cases where a request is sent to a topic with no responders.\nnkey: the public NKey to authenticate the client\nnkey_seed: the private NKey to authenticate the client\nping_interval: interval in seconds how often server should be pinged to check connection health. Default is 120.0 seconds\nmax_pings_out: how many pings in a row might fail before connection will be restarted. Default is 2\nretry_on_init_fail: if set connection handle will be returned even if initial connect fails. Otherwise error causing failure will be trown. Default is false\nignore_advertised_servers: ignores other cluster servers returned by server. Default is false\nretain_servers_order: try to connect server in order specified in url or list returned by the server. Defaylt is false\nsend_enqueue_when_disconnected: allows buffering outgoing messages during disconnection. Default is true\nreconnect_delays: vector of delays that reconnect is performed until connected again, by default it will try to reconnect every second without time limit.\nsend_buffer_limit: soft limit for buffer of messages pending. Default is 2097152 bytes, if too small operations that send messages to server (e.g. publish) may throw an exception\ndrain_timeout: Timeout for drain process. After timeout in case of not everyting is processed drain will stop and error will be reported.\ndrain_poll: Interval for drain to check if all messages in buffers are processed.\n\n\n\n\n\n","category":"function"},{"location":"connect/#Reconnecting","page":"Connection","title":"Reconnecting","text":"","category":"section"},{"location":"connect/","page":"Connection","title":"Connection","text":"Reconnect can be forced by user with reconnect function. This function can be also used for reconnect a connection in DISCONNECTED state after reconnect retries were exhausted.","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"reconnect","category":"page"},{"location":"connect/#NATS.reconnect","page":"Connection","title":"NATS.reconnect","text":"reconnect(connection; should_wait)\n\n\nForce a connection reconnect. If connection is CONNECTED this will close it and reopen again resubscribing all existing subscriptions. If connection is DISCONNECTED it will try to connect with all previously existing subscription restored. In case connection is already CONNECTING this method have no effect. If called on connection that is DRAINING or DRAINED error will be thrown.\n\nDuring reconnect period some messages both published and received by the connection might be lost.\n\nOptional keyword aruguments:\n\nshould_wait: If true method will block until reconnection process is started, default is true.\n\n\n\n\n\n","category":"function"},{"location":"connect/#Disconnecting","page":"Connection","title":"Disconnecting","text":"","category":"section"},{"location":"connect/","page":"Connection","title":"Connection","text":"To gracefully close connection drain function is provided.","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"drain(::NATS.Connection)","category":"page"},{"location":"connect/#NATS.drain-Tuple{NATS.Connection}","page":"Connection","title":"NATS.drain","text":"drain(connection)\n\n\nUnsubscribe all subscriptions, wait for precessing all messages in buffers, then close connection. Drained connection is no more usable. This method is used to gracefuly stop the process.\n\nUnderneeth it periodicaly checks for state of all buffers, interval for checks is configurable per connection with drain_poll parameter of connect method. It can also be set globally with NATS_DRAIN_POLL_INTERVAL_SECONDS environment variable. If not set explicitly default polling interval is 0.2 seconds.\n\nError will be written to log if drain not finished until timeout expires. Default timeout value is configurable per connection on connect with drain_timeout. Can be also set globally with NATS_DRAIN_TIMEOUT_SECONDS environment variable. If not set explicitly default drain timeout is 5.0 seconds.\n\n\n\n\n\n","category":"method"},{"location":"connect/","page":"Connection","title":"Connection","text":"To use NATS it is needed to create connection handle with connect function. Connection creates asynchronous tasks to handle messages from server, sending published messages, monitor state of TCP connection and reconnect on network failure.","category":"page"},{"location":"connect/#Connection-lifecycle","page":"Connection","title":"Connection lifecycle","text":"","category":"section"},{"location":"connect/","page":"Connection","title":"Connection","text":"When connect is called it tries to initialize connection with NATS server. If this process fails two things may happen depending on retry_on_init_fail option:","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"Rethrow exception causing protocol initialization failure.\nReturn connection in state CONNECTING continuing reconnect process in background ","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"Other wise connection in CONNECTED state is returned from connect.","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"In case of some critical failure like TCP connection closing or mallformed protocol message conection will enter CONNECTING and try reconnect according reconnect_delays specified. If it is unable to establish connection with allowed retries connection will land in DISCONNECTED state and only manual invocation of reconnect may restore it.","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"using GraphViz\n\nlifecycle = dot\"\"\" digraph G {\n    CONNECTING -> CONNECTED -> DRAINING -> DRAINED\n    CONNECTED -> CONNECTING [label=\"TCP failure\", fontname=\"Courier New\", fontsize=5, color=\"#aa0000\", fontcolor=\"#aa0000\"]\n    CONNECTING -> DISCONNECTED [label=\"reconnect\\nretries\\nexhausted\", fontname=\"Courier New\", fontsize=5, color=\"#aa0000\", fontcolor=\"#aa0000\"]\n    DISCONNECTED -> CONNECTING [label=\"reconnect()\", fontname=\"Courier New\", fontsize=5]\n    DISCONNECTED -> DRAINING [lable=\"unsubscribe and\\nprocess messages\"]\n}\"\"\"\n\nGraphViz.layout!(lifecycle, engine=\"dot\")\nopen(\"lifecycle.svg\", write = true) do f\n    GraphViz.render(f, lifecycle)\nend\nnothing","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"(Image: )","category":"page"},{"location":"connect/#Environment-variables","page":"Connection","title":"Environment variables","text":"","category":"section"},{"location":"connect/","page":"Connection","title":"Connection","text":"There are several ENV variables defined to provide default parameters for connect. It is advised to rather define ENV variables and use parameter less invocation like NATS.connect() for better code portability.","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"Parameter ENV variable Default value Sent to server\nurl NATS_CONNECT_URL localhost:4222 no\nverbose NATS_VERBOSE false yes\nverbose NATS_VERBOSE false yes\npedantic NATS_PEDANTIC false yes\ntls_required NATS_TLS_REQUIRED false yes\nauth_token NATS_AUTH_TOKEN  yes\nuser NATS_USER  yes\npass NATS_PASS  yes\njwt NATS_JWT  yes\nnkey NATS_NKEY  yes\nnkey_seed NATS_NKEY_SEED  no\ntls_ca_path NATS_TLS_CA_PATH  no\ntls_cert_path NATS_TLS_CERT_PATH  no\ntls_key_path NATS_TLS_KEY_PATH  no","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"Additionally some parameters are provided to fine tune client for specific deployment setup.","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"Parameter ENV variable Default value Sent to server\nping_interval NATS_PING_INTERVAL_SECONDS 120 no\nmax_pings_out NATS_MAX_PINGS_OUT 2 no\nretry_on_init_fail NATS_RETRY_ON_INIT_FAIL false no\nignore_advertised_servers NATS_IGNORE_ADVERTISED_SERVERS false no\nretain_servers_order NATS_RETAIN_SERVERS_ORDER false no\ndrain_timeout NATS_DRAIN_TIMEOUT_SECONDS 5.0 no\ndrain_poll NATS_DRAIN_POLL_INTERVAL_SECONDS 0.2 no\nsend_buffer_limit NATS_SEND_BUFFER_LIMIT_BYTES 2097152 no","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"Reconnect reconnect_delays default ExponentialBackOff also can be configured from ENV variables. This is recommended to configure it with them rather than pass delays as argument.","category":"page"},{"location":"connect/","page":"Connection","title":"Connection","text":"ENV variable Default value\nNATS_RECONNECT_RETRIES 220752000000000000\nNATS_RECONNECT_FIRST_DELAY 0.1\nNATS_RECONNECT_MAX_DELAY 5.0\nNATS_RECONNECT_FACTOR 5.0\nNATS_RECONNECT_JITTER 0.1","category":"page"},{"location":"jetstream/jetchannel/#JetChannel","page":"JetChannel","title":"JetChannel","text":"","category":"section"},{"location":"jetstream/jetchannel/#Example","page":"JetChannel","title":"Example","text":"","category":"section"},{"location":"jetstream/jetchannel/","page":"JetChannel","title":"JetChannel","text":"using NATS\nusing NATS.JetStream\nnc = NATS.connect()\nch = JetChannel{String}(nc, \"example_jetstream_channel\");\nput!(ch, \"test\");\ntake!(ch)\nt = @async take!(ch)\nsleep(1)\nistaskdone(t)\nput!(ch, \"some value\");\nsleep(0.1)\nt.result\nchannel_stream_delete(nc, \"example_jetstream_channel\")","category":"page"},{"location":"pubsub/#Publish-Subscribe","page":"Publish - Subscribe","title":"Publish - Subscribe","text":"","category":"section"},{"location":"pubsub/","page":"Publish - Subscribe","title":"Publish - Subscribe","text":"Functions implementing NATS Publish-Subscribe distribution model. For queue group 1:1 instead of default 1:N fanout configure subscriptions with the same queue_group argument.","category":"page"},{"location":"pubsub/","page":"Publish - Subscribe","title":"Publish - Subscribe","text":"publish\nsubscribe\nnext\nunsubscribe\ndrain","category":"page"},{"location":"pubsub/#NATS.publish","page":"Publish - Subscribe","title":"NATS.publish","text":"publish(connection, subject; ...)\npublish(connection, subject, data; reply_to)\n\n\nPublish data to a subject, payload is obtained with show method taking mime application/nats-payload, headers are obtained with show method taking mime application/nats-headers.\n\nThere are predefined convertion defined for String type. To publish headers there is defined conversion from tuple taking vector of pairs of strings.\n\nOptional parameters:\n\nreply_to: subject to which a result should be published\n\nExamples:\n\n    publish(nc, \"some_subject\", \"Some payload\")\n    publish(\"some_subject\", (\"Some payload\", [\"some_header\" => \"Example header value\"]))\n\n\n\n\n\n","category":"function"},{"location":"pubsub/#NATS.subscribe","page":"Publish - Subscribe","title":"NATS.subscribe","text":"subscribe(\n    f,\n    connection,\n    subject;\n    queue_group,\n    spawn,\n    channel_size,\n    monitoring_throttle_seconds\n)\n\n\nSubscribe to a subject.\n\nOptional keyword arguments are:\n\nqueue_group: NATS server will distribute messages across queue group members\nspawn: if true task will be spawn for each f invocation, otherwise messages are processed sequentially, default is false\nchannel_size: maximum items buffered for processing, if full messages will be ignored, default is 524288, can be configured globally with NATS_SUBSCRIPTION_CHANNEL_SIZE env variable\nmonitoring_throttle_seconds: time intervals in seconds that handler errors will be reported in logs, default is 5.0 seconds, can be configured globally with NATS_SUBSCRIPTION_ERROR_THROTTLING_SECONDS env variable\n\n\n\n\n\nsubscribe(connection, subject; queue_group, channel_size)\n\n\nSubscribe to a subject in synchronous mode. Client is supposed to call next manually to obtain messages.\n\nOptional keyword arguments are:\n\nqueue_group: NATS server will distribute messages across queue group members\nchannel_size: maximum items buffered for processing, if full messages will be ignored, default is 524288, can be configured globally with NATS_SUBSCRIPTION_CHANNEL_SIZE env variable\n\n\n\n\n\n","category":"function"},{"location":"pubsub/#NATS.next","page":"Publish - Subscribe","title":"NATS.next","text":"Obtains next message for synchronous subscription.\n\nOptional keyword arguments:\n\nno_wait: do not wait for next message, return nothing if buffer is empty\nno_throw: do not throw exception, returns nothing if cannot get next message\n\n\n\n\n\n","category":"function"},{"location":"pubsub/#NATS.unsubscribe","page":"Publish - Subscribe","title":"NATS.unsubscribe","text":"unsubscribe(connection, sub; max_msgs)\n\n\nUnsubscrible from a subject. sub is an object returned from subscribe or reply.\n\nOptional keyword arguments are:\n\nmax_msgs: maximum number of messages server will send after unsubscribe message received in server side, what can occur after some time lag\n\n\n\n\n\n","category":"function"},{"location":"pubsub/#NATS.drain","page":"Publish - Subscribe","title":"NATS.drain","text":"drain(connection)\n\n\nUnsubscribe all subscriptions, wait for precessing all messages in buffers, then close connection. Drained connection is no more usable. This method is used to gracefuly stop the process.\n\nUnderneeth it periodicaly checks for state of all buffers, interval for checks is configurable per connection with drain_poll parameter of connect method. It can also be set globally with NATS_DRAIN_POLL_INTERVAL_SECONDS environment variable. If not set explicitly default polling interval is 0.2 seconds.\n\nError will be written to log if drain not finished until timeout expires. Default timeout value is configurable per connection on connect with drain_timeout. Can be also set globally with NATS_DRAIN_TIMEOUT_SECONDS environment variable. If not set explicitly default drain timeout is 5.0 seconds.\n\n\n\n\n\ndrain(connection, sub; timer)\n\n\nUnsubscribe a subscription and wait for precessing all messages in the buffer.\n\nUnderneeth it periodicaly checks for state of the buffer, interval for checks is configurable per connection with drain_poll parameter of connect method. It can also be set globally with NATS_DRAIN_POLL_INTERVAL_SECONDS environment variable. If not set explicitly default polling interval is 0.2 seconds. \n\nOptional keyword arguments:\n\ntimer: error will be thrown if drain not finished until timer expires. Default value is configurable per connection on connect with drain_timeout. Can be also set globally with NATS_DRAIN_TIMEOUT_SECONDS environment variable. If not set explicitly default drain timeout is 5.0 seconds.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"examples/","page":"Quick start","title":"Quick start","text":"Start nats-server:","category":"page"},{"location":"examples/","page":"Quick start","title":"Quick start","text":"docker run -p 4222:4222 nats:latest","category":"page"},{"location":"examples/#Check-ping-pong-working","page":"Quick start","title":"Check ping - pong working","text":"","category":"section"},{"location":"examples/","page":"Quick start","title":"Quick start","text":"using NATS\nnc = NATS.connect()\n@time NATS.ping(nc) # First one may be slow due to compilation\n@time NATS.ping(nc)","category":"page"},{"location":"examples/#Publish-subscribe","page":"Quick start","title":"Publish subscribe","text":"","category":"section"},{"location":"examples/","page":"Quick start","title":"Quick start","text":"using NATS\nnc = NATS.connect()\nsub = subscribe(nc, \"test_subject\") do msg\n          @show payload(msg)\n      end\npublish(nc, \"test_subject\", \"Hello.\")\nsleep(0.2) # Wait for message.\ndrain(nc, sub)\npublish(nc, \"test_subject\", \"Hello.\") # Ater drain msg won't be delivared.","category":"page"},{"location":"examples/#Request-reply","page":"Quick start","title":"Request reply","text":"","category":"section"},{"location":"examples/","page":"Quick start","title":"Quick start","text":"> nats reply help.please 'OK, I CAN HELP!!!'\n\n20:35:19 Listening on \"help.please\" in group \"NATS-RPLY-22\"","category":"page"},{"location":"examples/","page":"Quick start","title":"Quick start","text":"using NATS\nnc = NATS.connect()\nrep = @time NATS.request(nc, \"help.please\");\npayload(rep)","category":"page"},{"location":"examples/#Work-queues","page":"Quick start","title":"Work queues","text":"","category":"section"},{"location":"examples/","page":"Quick start","title":"Quick start","text":"If subscription or reply is configured with queue_group, messages will be distributed equally between subscriptions with the same group.","category":"page"},{"location":"examples/","page":"Quick start","title":"Quick start","text":"using NATS\nconnection = NATS.connect()\nsub1 = reply(connection, \"some_subject\"; queue_group=\"group1\") do\n           \"Reply from worker 1\"\n       end\nsub2 = reply(connection, \"some_subject\"; queue_group=\"group1\") do\n           \"Reply from worker 2\"\n       end\n@time request(String, connection, \"some_subject\")\n@time request(String, connection, \"some_subject\")\n@time request(String, connection, \"some_subject\")\n@time request(String, connection, \"some_subject\")\n@time request(String, connection, \"some_subject\")\n@time request(String, connection, \"some_subject\")\n@time request(String, connection, \"some_subject\")\n@time drain(connection, sub1)\n@time drain(connection, sub2)","category":"page"},{"location":"interrupt_handling/#Handling-SIGINT","page":"Handling SIGINT","title":"Handling SIGINT","text":"","category":"section"},{"location":"interrupt_handling/","page":"Handling SIGINT","title":"Handling SIGINT","text":"When SIGINT is delivered, for instance when pressing CTRL+C in interactive session or externally by container runtime (for instance Kubernetes pod autoscaller) it is hard to ensure proper action is executed.","category":"page"},{"location":"interrupt_handling/","page":"Handling SIGINT","title":"Handling SIGINT","text":"Julia tasks might be scheduled on two threadpools, :interactive and :default and sizes of those threadpools are configured by --threads option. First one is intended to run short interactive tasks (like network communication), second one is for more CPU intensive operations that might block a thread for longer time.","category":"page"},{"location":"interrupt_handling/","page":"Handling SIGINT","title":"Handling SIGINT","text":"When SIGINT is delivered it is delivered only to the first thread and which threadpool it handles depends on --threads configuration.","category":"page"},{"location":"interrupt_handling/","page":"Handling SIGINT","title":"Handling SIGINT","text":"For instance:","category":"page"},{"location":"interrupt_handling/","page":"Handling SIGINT","title":"Handling SIGINT","text":"--threads 1 runs 0 :interactive threads and 1 :default threads.\n--threads 1,1 runs 1 :interactive threads and 1 :default threads.\n--threads 2,3 runs 3 :interactive threads and 2 :default threads.","category":"page"},{"location":"interrupt_handling/","page":"Handling SIGINT","title":"Handling SIGINT","text":"To ensure drain in NATS action is executed on interrupt signal julia should be run with exactly one :interactive thread. Otherwise some cpu intensive tasks may be scheduled on the first thread, or in case when there are more than one interactive threads, handler might be scheduled on different thread and miss interrupt signal.","category":"page"},{"location":"interrupt_handling/","page":"Handling SIGINT","title":"Handling SIGINT","text":"To ensure signal is delivered to the tasks that knows how to handle it, all :interactive tasks are wrapped into disable_sigint method except the one that have proper logic for connection draining.","category":"page"},{"location":"#NATS.jl-NATS-client-for-Julia.","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"","category":"section"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"NATS.jl allows to connect to NATS cluster from Julia and use patterns like publish-subscribe, request-reply, and  queue groups.","category":"page"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"WarningNATS is not a reliable communication protocol by design. Just like raw TCP connection it provides just at most once message delivery guarantees. For reliable communication you need to implement message acknowledgements in client applications or use JetStream protocol build on top of NATS.","category":"page"},{"location":"#Architecture-overview","page":"NATS.jl - NATS client for Julia.","title":"Architecture overview","text":"","category":"section"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"Each connection creates several asynchronous tasks for monitoring connection state, receiving messages from server, publishing messages to server. Flow is like this:","category":"page"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"Connect method is called\nTask for monitoring connection state is created\nAbove task spawns two more tasks for inbound and outbound communication\nIf any of tasks fails monitoring task tries to reconnect by spawning them again","category":"page"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"Those tasks should be scheduled on interactive threads to ensure fast responses to server, for instance, in case of PING message. To not block them tasks handling actual processing of subscription messages are ran in :default threadpool. Implication of this to ensure everything works smoothly user should do one of things:","category":"page"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"start julia with at least one interactive thread, see --threads option\nensure all handler methods are not CPU intensive if ran with single thread","category":"page"},{"location":"#Interrupt-handling","page":"NATS.jl - NATS client for Julia.","title":"Interrupt handling","text":"","category":"section"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"Graceful handling of interrupt is important in scenario of deployment to kubernetes cluster to handle pods auto scaling. There are several issues with Julia if it comes to handling signals:","category":"page"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"by default when SIGINT is delivered process is exited immediately, this can be prevented by calling Base.exit_on_sigint with false parameter.\neven when this is configured interrupts are delivered to all tasks running on thread 1. Depending on --threads configuration this thread might run all tasks (when --threads 1 which is default) or it can handle tasks scheduled on interactive threadpool (with --threads M,N where N is number of interactive threads). ","category":"page"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"To workaround this behavior all tasks started by NATS.jl are started inside disable_sigint wrapper, exception to this is special task designated to handling interrupts and scheduled on thread 1 with sticky flag set to true, what is achieved with @async macro. Limitation to this approach is that tasks started by user of NATS.jl or other packages may start tasks that will intercept InterruptException may ignore it or introduce unexpected behavior. On user side this might be mitigated by wrapping tasks functions into disable_sigint, also entrypoint to application should do this or handle interrupt correctly, for instance by calling NATS.drain to close all connections and wait until it is done.","category":"page"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"Future improvements in this matter might be introduced by open PR","category":"page"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"Current NATS.jl approach to handling signals is based on code and discussions from this PR. ","category":"page"},{"location":"#List-of-all-environment-variables","page":"NATS.jl - NATS client for Julia.","title":"List of all environment variables","text":"","category":"section"},{"location":"","page":"NATS.jl - NATS client for Julia.","title":"NATS.jl - NATS client for Julia.","text":"ENV variable Used in Default if not set Description\nNATS_AUTH_TOKEN connect nothing Client authorization token\nNATS_CONNECT_URL connect localhost:4222 Connection url, multiple urls to the same NATS cluster can be provided, for example nats:://localhost:4222,tls://localhost:4223\nNATS_DRAIN_POLL_INTERVAL_SECONDS connect 0.2 Interval in seconds how often drain will check if all buffers are consumed.\nNATS_DRAIN_TIMEOUT_SECONDS connect 5.0 Maximum time (in seconds) drain will block before returning error\nNATS_ENQUEUE_WHEN_DISCONNECTED connect true Allows buffering outgoing messages during disconnection\nNATS_IGNORE_ADVERTISED_SERVERS connect false Ignores other cluster servers returned by server\nNATS_JWT connect nothing The JWT that identifies a user permissions and account\nNATS_MAX_PINGS_OUT connect 3 How many pings in a row might fail before connection will be restarted\nNATS_NKEY connect nothing The public NKey to authenticate the client\nNATS_NKEY_SEED connect nothing the private NKey to authenticate the client\nNATS_PASS connect nothing Connection password, can be also passed in url nats://john:passw0rd@localhost:4223 but env variable has higher priority\nNATS_PEDANTIC connect false Turns on additional strict format checking, e.g. for properly formed subjects\nNATS_PING_INTERVAL connect 120.0 Interval in seconds how often server should be pinged to check connection health\nNATS_RECONNECT_FACTOR connect 5.0 Exponential reconnect delays configuration\nNATS_RECONNECT_FIRST_DELAY connect 0.1 Exponential reconnect delays configuration\nNATS_RECONNECT_JITTER connect 0.1 Exponential reconnect delays configuration\nNATS_RECONNECT_MAX_DELAY connect 5.0 Exponential reconnect delays configuration\nNATS_RECONNECT_RETRIES connect 220752000000000000 Exponential reconnect delays configuration\nNATS_REQUEST_TIMEOUT_SECONDS request 5.0 Time how long request will block before returning error\nNATS_RETAIN_SERVERS_ORDER connect false Changes connection url selection policy from random to sequence they were provided.\nNATS_RETRY_ON_INIT_FAIL connect false If set to true connect will not throw and error if connection init fails, but will continue retrying in background returning immediately connection in CONNECTING state.\nNATS_SEND_BUFFER_LIMIT_BYTES connect 2097152 Soft limit for buffer of messages pending. If too small operations that send messages to server (e.g. publish) may throw an exception\nNATS_SUBSCRIPTION_CHANNEL_SIZE subscribe 524288 How many messages waiting for processing subscription buffer can hold, if it gets full messages will be dropped.\nNATS_SUBSCRIPTION_ERROR_THROTTLING_SECONDS subscribe 5.0 How often subscription handler exceptions are reported in logs\nNATS_TLS_CA_PATH connect nothing Path to CA certificate file if TLS is used\nNATS_TLS_CERT_PATH connect nothing Path to client certificate file if TLS is used\nNATS_TLS_KEY_PATH connect nothing Path to client private certificate file if TLS is used\nNATS_TLS_REQUIRED connect false Forces TLS connection. TLS can be also forced by using url with tls scheme, example tls://localhost:4223\nNATS_USER connect nothing Connection username, can be also passed in url nats://john:passw0rd@localhost:4223 but env variable has higher priority\nNATS_VERBOSE connect false Turns on protocol acknowledgements","category":"page"}]
}
